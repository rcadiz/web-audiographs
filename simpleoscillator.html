<html>
<head>
<meta charset="UTF-8">
<style type="text/css">
</style>
<script type="text/javascript">
/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// Initialize the MIDI library.
(function (global, exports, perf) {
    'use strict';
    var midiIO,
    debug = false;
    if (debug) {
        window.console.warn('Debuggin enabled');
    }

//init: create plugin
    if (!window.navigator.requestMIDIAccess) {
      window.navigator.requestMIDIAccess = _requestMIDIAccess;
      if (!window.navigator.getMIDIAccess)
        window.navigator.getMIDIAccess = _getMIDIAccess;
    }

  function _JazzInstance() {
    this.inputInUse = false;
    this.outputInUse = false;

    // load the Jazz plugin
    var o1 = document.createElement("object");
    o1.id = "_Jazz" + Math.random() + "ie";
    o1.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90";

    this.activeX = o1;

    var o2 = document.createElement("object");
    o2.id = "_Jazz" + Math.random();
    o2.type="audio/x-jazz";
    o1.appendChild(o2);

    this.objRef = o2;

    var e = document.createElement("p");
    e.appendChild(document.createTextNode("This page requires the "));

    var a = document.createElement("a");
    a.appendChild(document.createTextNode("Jazz plugin"));
    a.href = "http://jazz-soft.net/";

    e.appendChild(a);
    e.appendChild(document.createTextNode("."));
    o2.appendChild(e);

    var insertionPoint = document.getElementById("MIDIPlugin");
    if (!insertionPoint) {
      // Create hidden element
      var insertionPoint = document.createElement("div");
      insertionPoint.id = "MIDIPlugin";
      insertionPoint.style.position = "absolute";
      insertionPoint.style.visibility = "hidden";
      insertionPoint.style.left = "-9999px";
      insertionPoint.style.top = "-9999px";
      document.body.appendChild(insertionPoint);
    }
    insertionPoint.appendChild(o1);

    if (this.objRef.isJazz)
      this._Jazz = this.objRef;
    else if (this.activeX.isJazz)
      this._Jazz = this.activeX;
    else
      this._Jazz = null;
    if (this._Jazz) {
      this._Jazz._jazzTimeZero = this._Jazz.Time();
      this._Jazz._perfTimeZero = window.performance.now();
    }
  }

  function _requestMIDIAccess( successCallback, errorCallback ) {
      new MIDIAccess( successCallback, errorCallback );
  }

  function _getMIDIAccess( successCallback, errorCallback ) {
      var message = "getMIDIAccess has been renamed to requestMIDIAccess.  Please update your code.";

      if (console.warn)
        console.warn( message );
      else
        console.log( message );
      new MIDIAccess( successCallback, errorCallback );
  }

  // API Methods

  function MIDIAccess( successCallback, errorCallback ) {
      this._jazzInstances = new Array();
      this._jazzInstances.push( new _JazzInstance() );

      if (this._jazzInstances[0]._Jazz) {
        this._Jazz = this._jazzInstances[0]._Jazz;
        this._successCallback = successCallback;
        window.setTimeout( _onReady.bind(this), 3 );
      } else {
          if (errorCallback)
            errorCallback( { code: 1 } );
      }
  }

  function _onReady() {
      if (this._successCallback)
          this._successCallback( this );
  }

  MIDIAccess.prototype.getInputs = function(  ) {
      if (!this._Jazz)
          return null;
      var list=this._Jazz.MidiInList();
      var inputs = new Array( list.length );

      for ( var i=0; i<list.length; i++ ) {
          inputs[i] = new MIDIPort( this, list[i], i, "input" );
      }
      return inputs;
  }

  MIDIAccess.prototype.getOutputs = function(  ) {
      if (!this._Jazz)
          return null;
      var list=this._Jazz.MidiOutList();
      var outputs = new Array( list.length );

      for ( var i=0; i<list.length; i++ ) {
          outputs[i] = new MIDIPort( this, list[i], i, "output" );
      }
      return outputs;
  }

  // TODO: remove these versions
  MIDIAccess.prototype.enumerateInputs = function(  ) {
    var message = "MIDIAccess.enumerateInputs has been renamed to MIDIAccess.getInputs.  Please update your code.";

    if (console.warn)
      console.warn( message );
    else
      console.log( message );
    return this.getInputs();
  }

  MIDIAccess.prototype.enumerateOutputs = function(  ) {
    var message = "MIDIAccess.enumerateOutputs has been renamed to MIDIAccess.getOutputs.  Please update your code.";

    if (console.warn)
      console.warn( message );
    else
      console.log( message );
    return this.getOutputs();
  }

  MIDIAccess.prototype.getInput = function( target ) {
      if (target==null)
          return null;
      return new MIDIInput( this, target );
  }

  MIDIAccess.prototype.getOutput = function( target ) {
      if (target==null)
          return null;
      return new MIDIOutput( this, target );
  }

  function MIDIPort( midi, port, index, type ) {
      this._index = index;
      this._midi = midi;
      this.type = type;

      // Can't get manu/version from Jazz
      this.name = port;
      this.manufacturer = null;
      this.version = null;
      this.fingerprint = "" + index + "." + this.name;
  }

  MIDIPort.prototype.toString = function() {
      return ("type: "+ this.type + "name: '" + this.name + "' manufacturer: '" +
      this.manufacturer + "' version: " + this.version + " fingerprint: '" + this.fingerprint + "'" );
  }

  function MIDIInput( midiAccess, target ) {
    this.onmessage = null;
    this._listeners = [];
    this._midiAccess = midiAccess;

    var inputInstance = null;
    for (var i=0; (i<midiAccess._jazzInstances.length)&&(!inputInstance); i++) {
      if (!midiAccess._jazzInstances[i].inputInUse)
        inputInstance=midiAccess._jazzInstances[i];
    }
    if (!inputInstance) {
      inputInstance = new _JazzInstance();
      midiAccess._jazzInstances.push( inputInstance );
    }
    inputInstance.inputInUse = true;

    this._jazzInstance = inputInstance._Jazz;

    // target can be a MIDIPort or DOMString
    if ( target instanceof MIDIPort ) {
      this._deviceName = target.name;
      this._index = target._index;
    } else if (typeof target === "number") { // target is numerical index
      this._index = target;
      var list=this._jazzInstance.MidiInList();
      this._deviceName = list[target];
    } else if ( typeof target === 'string' ) { // fingerprint
      var dot = target.indexOf(".");
      this._index = parseInt( target.slice( 0, dot ) );
      this._deviceName = target.slice( dot + 1 );
    }

    this._input = this._jazzInstance.MidiInOpen( this._index, _midiProc.bind(this) );
  }

  // Introduced in DOM Level 2:
  MIDIInput.prototype.addEventListener = function (type, listener, useCapture ) {
    if (type != "message")
      return;
    for (var i=0; i<this._listeners.length; i++)
      if (this._listeners[i] == listener)
        return;
    this._listeners.push( listener );
  }

  MIDIInput.prototype.removeEventListener = function (type, listener, useCapture ) {
    if (type != "message")
      return;
    for (var i=0; i<this._listeners.length; i++)
      if (this._listeners[i] == listener) {
        this._listeners.splice( i, 1 );  //remove it
        return;
      }
  }

  MIDIInput.prototype.preventDefault = function() {
    this._pvtDef = true;
  }

  MIDIInput.prototype.dispatchEvent = function (evt) {
    this._pvtDef = false;

    // dispatch to listeners
    for (var i=0; i<this._listeners.length; i++)
      if (this._listeners[i].handleEvent)
        this._listeners[i].handleEvent.bind(this)( evt );
      else
        this._listeners[i].bind(this)( evt );

    if (this.onmessage)
      this.onmessage( evt );

    return this._pvtDef;
  }

  function _midiProc( timestamp, data ) {
    var evt = document.createEvent( "Event" );
    evt.initEvent( "cutonEvent", false, false );
    evt.timestamp = parseFloat( timestamp.toString()) + this._jazzInstance._perfTimeZero;
    var length = 0;
    var i,j;

    // Jazz sometimes passes us multiple messages at once, so we need to parse them out
    // and pass them one at a time.
    for (i=0; i<data.length; i+=length) {
      switch (data[i] & 0xF0) {
        case 0x80:  // note off
        case 0x90:  // note on
        case 0xA0:  // polyphonic aftertouch
        case 0xB0:  // control change
        case 0xE0:  // channel mode
          length = 3;
          break;

        case 0xC0:  // program change
        case 0xD0:  // channel aftertouch
          length = 2;
          break;

        case 0xF0:
          switch (data[i]) {
            case 0xf0:  // variable-length sysex.
              // count the length;
              length = -1;
              for (j=i+1; (j<data.length) && (data[j] != 0xF7); j++)
                ;
              length = j-i+1;
              break;

            case 0xF1:  // MTC quarter frame
            case 0xF3:  // song select
              length = 2;
              break;

            case 0xF2:  // song position pointer
              length = 3;
              break;

            default:
              length = 1;
              break;
          }
          break;
      }
      evt.data = new Uint8Array(data.slice(i, length+i));
      this.dispatchEvent( evt );
    }
  }

  function MIDIOutput( midiAccess, target ) {
    this._midiAccess = midiAccess;

    var outputInstance = null;
    for (var i=0; (i<midiAccess._jazzInstances.length)&&(!outputInstance); i++) {
      if (!midiAccess._jazzInstances[i].outputInUse)
        outputInstance=midiAccess._jazzInstances[i];
    }
    if (!outputInstance) {
      outputInstance = new _JazzInstance();
      midiAccess._jazzInstances.push( outputInstance );
    }
    outputInstance.outputInUse = true;

    this._jazzInstance = outputInstance._Jazz;

    // target can be a MIDIPort or DOMString
    if ( target instanceof MIDIPort ) {
      this._deviceName = target.name;
      this._index = target._index;
    } else if (typeof target === "number") { // target is numerical index
      this._index = target;
      var list=this._jazzInstance.MidiOutList();
      this._deviceName = list[target];
    } else if ( typeof target === 'string' ) { // fingerprint
      var dot = target.indexOf(".");
      this._index = parseInt( target.slice( 0, dot ) );
      this._deviceName = target.slice( dot + 1 );
    }

    this._jazzInstance.MidiOutOpen(this._deviceName);
  }

  function _sendLater() {
      this.jazz.MidiOutLong( this.data );    // handle send as sysex
  }

  MIDIOutput.prototype.send = function( data, timestamp ) {
    var delayBeforeSend = 0;
    if (data.length==0)
      return false;

    if (timestamp)
      delayBeforeSend = Math.floor( timestamp - window.performance.now() );

    if (timestamp && (delayBeforeSend>1)) {
      var sendObj = new Object;
      sendObj.jazz = this._jazzInstance;
      sendObj.data = data;

      window.setTimeout( _sendLater.bind(sendObj), delayBeforeSend );
    } else {
      this._jazzInstance.MidiOutLong( data );
    }
    return true;
  }

}(window));

// Polyfill window.performance.now() if necessary.
(function (exports) {
    var perf = {},
        props;

    function findAlt() {
        var prefix = "moz,webkit,opera,ms".split(","),
            i = prefix.length,
            //worst case, we use Date.now()
            props = {
                value: function (start) {
                    return function () {
                        return Date.now() - start;
                    }
                }(Date.now())
            };

        //seach for vendor prefixed version
        for (; i >= 0; i--) {
            if ((prefix[i] + "Now") in exports.performance) {
                props.value = function (method) {
                    return function () {
                        exports.performance[method]();
                    }
                }(prefix[i] + "Now");
                return props;
            }
        }

        //otherwise, try to use connectionStart
        if ("timing" in exports.performance &&
            "connectStart" in exports.performance.timing) {
            //this pretty much approximates performance.now() to the millisecond
            props.value = function (start) {
                return function(){Date.now() - start;}
            }(exports.performance.timing.connectStart);
        }
        return props;
    }

    //if already defined, bail
    if (("performance" in exports) && ("now" in exports.performance)) {
        return;
    }
    if (!("performance" in exports)) {
        Object.defineProperty(exports, "performance", {
            get: function () {
                return perf;
            }
        });
        //otherwise, perforance is there, but not "now()"
    }
    props = findAlt();
    Object.defineProperty(exports.performance, "now", props);
}(window));



/* ------------------------------------------------------------
name: "simpleoscillator"
Code generated with Faust 2.5.25 (https://faust.grame.fr)
Compilation options: ajs, -scal -ftz 0
------------------------------------------------------------ */
/*
 faust2webaudio
 
 Primarily written by Myles Borins
 During the Spring 2013 offering of Music 420b with Julius Smith
 A bit during the Summer of 2013 with the help of Joshua Kit Clayton
 And finally a sprint during the late fall of 2013 to get everything working
 A Special thanks to Yann Orlarey and StÃ©phane Letz
 
 faust2webaudio is distributed under the terms the MIT or GPL2 Licenses.
 Choose the license that best suits your project. The text of the MIT and GPL
 licenses are at the root directory.
 
 Additional code : GRAME 2014
 
 */
 
'use strict';

var faust = faust || {};



function simpleoscillatorModule(global, foreign, buffer) {
	
	'use asm';
	
	var HEAP32 = new global.Int32Array(buffer);
	var HEAPF = new global.Float32Array(buffer);
	
	var imul = foreign.imul;
	var log = foreign.log;
	var round = foreign.round;
	
	var max_f = foreign.max;
	var min_f = foreign.min;
	var powf = foreign.pow;
	function fmodf(x, y) { x = +x; y = +y; return +(x % y); }
	function log10f(a) { a = +a; return +(+log(a) / +log(10.)); }
	function remainderf(x, y) { x = +x; y = +y; return +(x - +round(x/y) * y); }
	
	function getNumInputs(dsp) {
		dsp = dsp | 0;
		return 0;
	}
	
	function getNumOutputs(dsp) {
		dsp = dsp | 0;
		return 1;
	}
	
	function classInit(dsp, samplingFreq) {
		dsp = dsp | 0;
		samplingFreq = samplingFreq | 0;
		
	}
	
	function instanceConstants(dsp, samplingFreq) {
		dsp = dsp | 0;
		samplingFreq = samplingFreq | 0;
		HEAP32[dsp + 8 >> 2] = (samplingFreq | 0);
		HEAPF[dsp + 12 >> 2] = +(6.28318548 / +(min_f(192000., +(max_f(1., +((HEAP32[dsp + 8 >> 2] | 0)))))));
		
	}
	
	function instanceResetUserInterface(dsp) {
		dsp = dsp | 0;
		HEAPF[dsp + 16 >> 2] = 1000.;
		HEAPF[dsp + 44 >> 2] = 0.;
		
	}
	
	function instanceClear(dsp) {
		dsp = dsp | 0;
		var l0 = 0;
		var l1 = 0;
		var l2 = 0;
		var l3 = 0;
		var l4 = 0;
		for (l0 = 0; (((l0 | 0) < 2) | 0); l0 = (((l0 | 0) + 1) | 0)) {
			HEAP32[dsp + 0 + ((l0 | 0) << 2) >> 2] = 0;
			
		}
		for (l1 = 0; (((l1 | 0) < 2) | 0); l1 = (((l1 | 0) + 1) | 0)) {
			HEAPF[dsp + 20 + ((l1 | 0) << 2) >> 2] = 0.;
			
		}
		for (l2 = 0; (((l2 | 0) < 2) | 0); l2 = (((l2 | 0) + 1) | 0)) {
			HEAPF[dsp + 28 + ((l2 | 0) << 2) >> 2] = 0.;
			
		}
		for (l3 = 0; (((l3 | 0) < 2) | 0); l3 = (((l3 | 0) + 1) | 0)) {
			HEAPF[dsp + 36 + ((l3 | 0) << 2) >> 2] = 0.;
			
		}
		for (l4 = 0; (((l4 | 0) < 2) | 0); l4 = (((l4 | 0) + 1) | 0)) {
			HEAPF[dsp + 48 + ((l4 | 0) << 2) >> 2] = 0.;
			
		}
		
	}
	
	function init(dsp, samplingFreq) {
		dsp = dsp | 0;
		samplingFreq = samplingFreq | 0;
		classInit(dsp, samplingFreq);
		instanceInit(dsp, samplingFreq);
	}
	
	function instanceInit(dsp, samplingFreq) {
		dsp = dsp | 0;
		samplingFreq = samplingFreq | 0;
		instanceConstants(dsp, samplingFreq);
		instanceResetUserInterface(dsp);
		instanceClear(dsp);
	}
	
	function getSampleRate(dsp) {
		dsp = dsp | 0;
		return HEAP32[dsp + 8 >> 2] | 0;
	}
	
	function setParamValue(dsp, offset, value) {
		dsp = dsp | 0;
		offset = offset | 0;
		value = +value;
		HEAPF[dsp + offset >> 2] = value;
	}
	
	function getParamValue(dsp, offset) {
		dsp = dsp | 0;
		offset = offset | 0;
		return +(HEAPF[dsp + offset >> 2]);
	}
	
	function compute(dsp, count, inputs, outputs) {
		dsp = dsp | 0;
		count = count | 0;
		inputs = inputs | 0;
		outputs = outputs | 0;
		var output0 = 0;
		var fSlow0 = 0.;
		var fSlow1 = 0.;
		var i = 0;
		output0 = (HEAP32[outputs + (0 << 2) >> 2] | 0);
		fSlow0 = +(+(HEAPF[dsp + 12 >> 2]) * +(+(HEAPF[dsp + 16 >> 2])));
		fSlow1 = +(0.00100000005 * +(powf(10., +(0.0500000007 * +(+(HEAPF[dsp + 44 >> 2]))))));
		for (i = 0; (((i | 0) < (count | 0)) | 0); i = (((i | 0) + 1) | 0)) {
			HEAP32[dsp + 0 + (0 << 2) >> 2] = 1;
			HEAPF[dsp + 20 + (0 << 2) >> 2] = +(+(HEAPF[dsp + 20 + (1 << 2) >> 2]) + +(+(fSlow0) * +(0. - +(HEAPF[dsp + 36 + (1 << 2) >> 2]))));
			HEAPF[dsp + 28 + (0 << 2) >> 2] = +(+(+(HEAPF[dsp + 28 + (1 << 2) >> 2]) + +(+(fSlow0) * +(HEAPF[dsp + 20 + (0 << 2) >> 2]))) + +(((1 - (HEAP32[dsp + 0 + (1 << 2) >> 2] | 0)) | 0)));
			HEAPF[dsp + 36 + (0 << 2) >> 2] = +(HEAPF[dsp + 28 + (0 << 2) >> 2]);
			HEAPF[dsp + 48 + (0 << 2) >> 2] = +(+(fSlow1) + +(0.999000013 * +(HEAPF[dsp + 48 + (1 << 2) >> 2])));
			HEAPF[output0 + ((i | 0) << 2) >> 2] = +(+(+(HEAPF[dsp + 36 + (0 << 2) >> 2]) * +(HEAPF[dsp + 48 + (0 << 2) >> 2])));
			HEAP32[dsp + 0 + (1 << 2) >> 2] = (HEAP32[dsp + 0 + (0 << 2) >> 2] | 0);
			HEAPF[dsp + 20 + (1 << 2) >> 2] = +(HEAPF[dsp + 20 + (0 << 2) >> 2]);
			HEAPF[dsp + 28 + (1 << 2) >> 2] = +(HEAPF[dsp + 28 + (0 << 2) >> 2]);
			HEAPF[dsp + 36 + (1 << 2) >> 2] = +(HEAPF[dsp + 36 + (0 << 2) >> 2]);
			HEAPF[dsp + 48 + (1 << 2) >> 2] = +(HEAPF[dsp + 48 + (0 << 2) >> 2]);
			
		}
		
	}
	
	return { getNumInputs : getNumInputs, getNumOutputs : getNumOutputs, classInit : classInit, instanceInit : instanceInit, instanceConstants : instanceConstants, instanceResetUserInterface : instanceResetUserInterface, instanceClear : instanceClear, init : init, getSampleRate : getSampleRate, setParamValue : setParamValue, getParamValue : getParamValue, compute : compute };
}

function getSizesimpleoscillator() {
	return 56;
}

function getPathTablesimpleoscillator() {
	var pathTable = [];
	pathTable["/Oscillator/freq"] = 16;
	pathTable["/Oscillator/volume"] = 44;
	return pathTable;
}

function getJSONsimpleoscillator() {
	return "{\"name\":\"simpleoscillator\",\"filename\":\"simpleoscillator\",\"inputs\":\"0\",\"outputs\":\"1\",\"meta\":[{\"basics.lib/name\":\"Faust Basic Element Library\"},{\"basics.lib/version\":\"0.0\"},{\"filename\":\"simpleoscillator\"},{\"maths.lib/author\":\"GRAME\"},{\"maths.lib/copyright\":\"GRAME\"},{\"maths.lib/license\":\"LGPL with exception\"},{\"maths.lib/name\":\"Faust Math Library\"},{\"maths.lib/version\":\"2.1\"},{\"name\":\"simpleoscillator\"},{\"oscillators.lib/name\":\"Faust Oscillator Library\"},{\"oscillators.lib/version\":\"0.0\"},{\"signals.lib/name\":\"Faust Signal Routing Library\"},{\"signals.lib/version\":\"0.0\"}],\"ui\":[{\"type\":\"vgroup\",\"label\":\"Oscillator\",\"items\":[{\"type\":\"hslider\",\"label\":\"freq\",\"address\":\"/Oscillator/freq\",\"meta\":[{\"unit\":\"Hz\"}],\"init\":\"1000\",\"min\":\"20\",\"max\":\"24000\",\"step\":\"1\"},{\"type\":\"hslider\",\"label\":\"volume\",\"address\":\"/Oscillator/volume\",\"meta\":[{\"unit\":\"dB\"}],\"init\":\"0\",\"min\":\"-96\",\"max\":\"0\",\"step\":\"0.1\"}]}]}";
}

function metadatasimpleoscillator(m) {
	m.declare("basics.lib/name", "Faust Basic Element Library");
	m.declare("basics.lib/version", "0.0");
	m.declare("filename", "simpleoscillator");
	m.declare("maths.lib/author", "GRAME");
	m.declare("maths.lib/copyright", "GRAME");
	m.declare("maths.lib/license", "LGPL with exception");
	m.declare("maths.lib/name", "Faust Math Library");
	m.declare("maths.lib/version", "2.1");
	m.declare("name", "simpleoscillator");
	m.declare("oscillators.lib/name", "Faust Oscillator Library");
	m.declare("oscillators.lib/version", "0.0");
	m.declare("signals.lib/name", "Faust Signal Routing Library");
	m.declare("signals.lib/version", "0.0");
}


// Standard Faust simpleoscillator

faust.simpleoscillator = function (context, buffer_size) {

    var handler = null;
    var ins, outs;
    var scriptProcessor;
    
    var dspInChannnels = [];
    var dspOutChannnels = [];
   
    // Keep JSON parsed object
    var json_object = JSON.parse(getJSONsimpleoscillator());
    
    function getNumInputsAux () 
    {
        return (json_object.inputs !== undefined) ? parseInt(json_object.inputs) : 0;
    }
    
    function getNumOutputsAux () 
    {
        return (json_object.outputs !== undefined) ? parseInt(json_object.outputs) : 0;
    }
    
    var numIn = getNumInputsAux();
    var numOut = getNumOutputsAux();
     
    // Memory allocator
    var ptr_size = 4; 
    var sample_size = 4;
    
    function pow2limit (x)
    {
        var n = 65536; // Minimum = 64 kB
        while (n < x) { n = 2 * n; }
        return n;
    }
     
    var memory_size = pow2limit(getSizesimpleoscillator() + (numIn + numOut) * (ptr_size + (buffer_size * sample_size)));
   
    var HEAP = new ArrayBuffer(memory_size);
    var HEAP32 = new Int32Array(HEAP);
    var HEAPF32 = new Float32Array(HEAP);
     
    console.log(HEAP);
    console.log(HEAP32);
    console.log(HEAPF32);
 
    // bargraph
    var ouputs_timer = 5;
    var ouputs_items = [];
     
    // input items
    var inputs_items = [];
     
    // Start of HEAP index
    var audio_heap_ptr = 0;
     
    // Setup pointers offset
    var audio_heap_ptr_inputs = audio_heap_ptr; 
    var audio_heap_ptr_outputs = audio_heap_ptr_inputs + (numIn * ptr_size);
     
    // Setup buffer offset
    var audio_heap_inputs = audio_heap_ptr_outputs + (numOut * ptr_size);
    var audio_heap_outputs = audio_heap_inputs + (numIn * buffer_size * sample_size);
    
    // Setup simpleoscillator offset
    var dsp_start = audio_heap_outputs + (numOut * buffer_size * sample_size);
     
    // Start of simpleoscillator memory
    var dsp = dsp_start;
 
    // ASM module
    var factory = simpleoscillatorModule(window, window.Math, HEAP);
    console.log(factory);
 
    var pathTable = getPathTablesimpleoscillator();
    
    // Allocate table for 'setParamValue'
    var value_table = [];
        
    function update_outputs () 
    {
        if (ouputs_items.length > 0 && handler && ouputs_timer-- === 0) {
            ouputs_timer = 5;
            for (var i = 0; i < ouputs_items.length; i++) {
                handler(ouputs_items[i], factory.getParamValue(dsp, pathTable[ouputs_items[i]]));
            }
        }
    }
    
    function compute (e) 
    {
        var i, j;
        
        // Read inputs
        for (i = 0; i < numIn; i++) {
            var input = e.inputBuffer.getChannelData(i);
            var dspInput = dspInChannnels[i];
            for (j = 0; j < input.length; j++) {
                dspInput[j] = input[j];
            }
        }
        
        // Update control state
        for (i = 0; i < inputs_items.length; i++) {
            var path = inputs_items[i];
            var values = value_table[path];
            factory.setParamValue(dsp, pathTable[path], values[0]);
            values[0] = values[1];
        }
        
        // Compute
        factory.compute(dsp, buffer_size, ins, outs);
       
        // Update bargraph
        update_outputs();
        
        // Write outputs
        for (i = 0; i < numOut; i++) {
            var output = e.outputBuffer.getChannelData(i);
            var dspOutput = dspOutChannnels[i];
            for (j = 0; j < output.length; j++) {
                output[j] = dspOutput[j];
            }
        }
    };
         
    // JSON parsing
    function parse_ui (ui) 
    {
        for (var i = 0; i < ui.length; i++) {
            parse_group(ui[i]);
        }
    }
    
    function parse_group (group) 
    {
        if (group.items) {
            parse_items(group.items);
        }
    }
    
    function parse_items (items) 
    {
        var i;
        for (i = 0; i < items.length; i++) {
            parse_item(items[i]);
        }
    }
    
    function parse_item (item) 
    {
        if (item.type === "vgroup" 
        	|| item.type === "hgroup" 
        	|| item.type === "tgroup") {
            parse_items(item.items);
        } else if (item.type === "hbargraph" 
        	|| item.type === "vbargraph") {
            // Keep bargraph adresses
            ouputs_items.push(item.address);
        } else if (item.type === "vslider" 
        	|| item.type === "hslider" 
        	|| item.type === "button" 
        	|| item.type === "checkbox" 
        	|| item.type === "nentry") {
            // Keep inputs adresses
            inputs_items.push(item.address);
        }
    }
      
    function init ()
    {
        var i;
         
        // Setup web audio context
        console.log("buffer_size %d", buffer_size);
        scriptProcessor = context.createScriptProcessor(buffer_size, numIn, numOut);
        scriptProcessor.onaudioprocess = compute;
        
        if (numIn > 0) {
            ins = audio_heap_ptr_inputs; 
            for (i = 0; i < numIn; i++) { 
                HEAP32[(ins >> 2) + i] = audio_heap_inputs + ((buffer_size * sample_size) * i);
            }
     
            // Prepare Ins buffer tables
            var dspInChans = HEAP32.subarray(ins >> 2, (ins + numIn * ptr_size) >> 2);
            for (i = 0; i < numIn; i++) {
                dspInChannnels[i] = HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + buffer_size * sample_size) >> 2);
            }
        }
        
        if (numOut > 0) {
            outs = audio_heap_ptr_outputs; 
            for (i = 0; i < numOut; i++) { 
                HEAP32[(outs >> 2) + i] = audio_heap_outputs + ((buffer_size * sample_size) * i);
            }
          
            // Prepare Out buffer tables
            var dspOutChans = HEAP32.subarray(outs >> 2, (outs + numOut * ptr_size) >> 2);
            for (i = 0; i < numOut; i++) {
                dspOutChannnels[i] = HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + buffer_size * sample_size) >> 2);
            }
        }
                                
        // bargraph
        parse_ui(json_object.ui);
        
        // Init simpleoscillator
        factory.init(dsp, context.sampleRate);
        
        // Init 'value' table
        for (i = 0; i < inputs_items.length; i++) {
            var path = inputs_items[i];
            var values = new Float32Array(2);
            values[0] = values[1] = factory.getParamValue(dsp, pathTable[path]);
            value_table[path] = values;
        }
    }
    
    init();
    
    // External API
    return {
    	
        destroy : function ()
        {
            // Nothing to do
        },
        
        getNumInputs : function () 
        {
            return getNumInputsAux();
        },
        
        getNumOutputs : function () 
        {
            return getNumOutputsAux();
        },
        
        init : function (sample_rate) 
        {
            factory.init(dsp, sample_rate);
        },
        
        instanceInit : function (sample_rate) 
        {
            factory.instanceInit(dsp, sample_rate);
        },
        
        instanceConstants : function (sample_rate) 
        {
            factory.instanceConstants(dsp, sample_rate);
        },
        
        instanceResetUserInterface : function () 
        {
            factory.instanceResetUserInterface(dsp);
        },
        
        instanceClear : function () 
        {
            factory.instanceClear(dsp);
        },
        
        // Connect/disconnect to another node
        connect : function (node) 
        {
            if (node.getProcessor !== undefined) {
                scriptProcessor.connect(node.getProcessor());
            } else {
                scriptProcessor.connect(node);
            }
        },

        disconnect : function (node) 
        {
            if (node.getProcessor !== undefined) {
                scriptProcessor.disconnect(node.getProcessor());
            } else {
                scriptProcessor.disconnect(node);
            }
        },
        
        setHandler : function (hd)
        {
            handler = hd;
        },
        
        start : function () 
        {
            scriptProcessor.connect(context.destination);
        },

        stop : function () 
        {
            scriptProcessor.disconnect(context.destination);
        },

        setParamValue : function (path, val) 
        {
            var values = value_table[path];
            if (values) {
                if (factory.getParamValue(dsp, pathTable[path]) === values[0]) {
                    values[0] = val;
                } 
                values[1] = val;
            }
        },

        getParamValue : function (path) 
        {
            return factory.getParamValue(dsp, pathTable[path]);
        },
        
        controls : function()
        {
            return inputs_items;
        },
        
        json : function ()
        {
            return getJSONsimpleoscillator();
        },
        
        getProcessor : function ()
        {
            return scriptProcessor;
        }
    };
};

</script>
</head>
<body>



<script>
    
'use strict';

var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();
var audio_input = null;
var simpleoscillator = null;
var faustsvg = null;
var dsp_code = null;

function changeBufferSize(buffer_size)
{
    var new_buffer_size = buffer_size.options[buffer_size.selectedIndex].value;
    console.log(new_buffer_size);
    startNewsimpleoscillator(new_buffer_size);
}
 
// Audio input handling

function activateAudioInput()
{
    if (!navigator.getUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
    }
   
    if (navigator.getUserMedia) {
        navigator.getUserMedia({audio: { echoCancellation: false }}, getDevice, function(e) {
                alert('Error getting audio input');
                console.log(e);
                audio_input = null;
        });
    } else {
        alert('Audio input API not available');
    }
}

function getDevice(device) 
{
    // Create an AudioNode from the stream.
    audio_input = audio_context.createMediaStreamSource(device);
    
    // Connect it to the destination.
    audio_input.connect(simpleoscillator.getProcessor());
}

function startsimpleoscillatorAux(buffer_size) 
{
    console.log("startsimpleoscillator %d", buffer_size);
    if (simpleoscillator) {
        if (audio_input) {
            audio_input.disconnect(simpleoscillator.getProcessor());
        }
        _f4u$t.hard_delete(faustsvg);
        simpleoscillator.stop();
        simpleoscillator.destroy();
    }
    simpleoscillator = faust.simpleoscillator(audio_context, buffer_size);
    if (simpleoscillator.getNumInputs() > 0) {
        activateAudioInput();
    }
    simpleoscillator.start();
    console.log(simpleoscillator.json());
    console.log(simpleoscillator.controls());
    
    // kludge...ideally, this needs to not be part of the imported JS
    _f4u$t.main_loop = function() {}
    
    faustsvg = $('<div />');
    $('body').append(faustsvg);
    var handler = _f4u$t.main(simpleoscillator.json(), faustsvg, simpleoscillator.setParamValue);
    simpleoscillator.setHandler(handler);
}

function startsimpleoscillator() 
{
    startsimpleoscillatorAux(1024);
}

function startNewsimpleoscillator(buffer_size) 
{
    startsimpleoscillatorAux(buffer_size);
}

// To activate audio on iOS
window.addEventListener('touchstart', function() {

	// create empty buffer
	var buffer = audio_context.createBuffer(1, 1, 22050);
	var source = audio_context.createBufferSource();
	source.buffer = buffer;

	// connect to output (your speakers)
	source.connect(audio_context.destination);

	// play the file
	source.noteOn(0);

}, false);

// General

$(startsimpleoscillator);

</script>

<P>
<center>
<form method="POST" name="menu" >
  <select name="selectedBuffer" 
    onChange="changeBufferSize(this.form.selectedBuffer)">
    <option value = 256> 256 </option>
    <option value = 512> 512 </option>
    <option selected value = 1024> 1024 </option>
    <option value = 2048> 2048 </option>
    <option value = 4096> 4096 </option>
    <option value = 8192> 8192 </option>
  </select>
</form>
</center>

</body>
</html>
